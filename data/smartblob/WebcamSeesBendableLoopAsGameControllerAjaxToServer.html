<!DOCTYPE html>
<html><body>
<video width="128" height="128" id="video" autoplay="autoplay" style="transform:scale(-1,1);"></video>
<canvas width="128" height="128" id="canvas" style="transform:scale(-1,1);"></canvas>
Edgedetect is in earlier code and needs to be stored in Uint8Array, wrapped in ByteRect. Temporarily I removed it to find what was lagging the video, canvas, andOr ajax. Its still too laggy even for casual gamers, but I think it can be fixed. It will never be low enough lag for hardcore gamers using a cheap webcam, but maybe better webcams or body tracking devices can hook in later. I'm going forward with the game content soon, after I get the basic webcam controls working. For now, you move as browser sees, and play the game in java window, so you need both on half the screen. I'll add a big canvas and use json to transfer the game state to interpolate speeds of each part of object in realtime, so it will be a browser game played through a java server which may be local or play with your friends in a hackerspace.
<script>

//Ben F Rayfield offers Smartblob opensource GNU GPL 2+

var ajaxCallsInProgress = 0;

var video = document.getElementById('video');
var videoStream = null;

var canvas = document.getElementById('canvas');
var canvasContext = null;

var canvasImageData = null;
var canvasPixels = null;

var byteRect = null;

var colorDimRed = 0;
var colorDimGreen = 1;
var colorDimBlue = 2;
var colorDimAlpha = 3;

var log = function(line){
	console.log(line);
};

var time = function(){
	return Date.now()*.001;
};

var toStringCheckForUndefinedAndNull = function(ob){
	if(ob === undefined) return "<undef>";
	if(ob == null) return "<nul>";
	return ""+ob;
};

var fourHexDigitsForBifraction = function(bifraction){
	var s = Math.max(0, Math.min(Math.floor((.5+.5*bifraction)*0x10000), 0xffff)).toString(16);
	while(s.length < 4) s = '0'+s;
	return s;
};

ajaxSend = function(stringSendToServer){
	//log('ajax when='+time());
	ajaxCallsInProgress++;
	//log('Saying to server: '+stringSendToServer);
	try{
		var jax = 'no ajax object created';
		if(window.XMLHttpRequest){ 
			jax = new window.XMLHttpRequest();
		}else if(window.ActiveXObject){
			jax = new window.ActiveXObject('Microsoft.XMLHTTP');
		}
		/*FIXME get response may be slowing it down jax.onreadystatechange = function(){
			if(jax.readyState == 4){
				ajaxReceive(stringSendToServer, jax.responseText);
			}
		};*/
		jax.open('GET', 'http://'+window.location.host+'/'+stringSendToServer, true);
		jax.send(null);
	}catch(e){
		alert(e);
	}
};

ajaxReceive = function(stringSentToServer, stringReceivedFromServer){
	lastAjaxFinishedWhen = time();
	ajaxCallsInProgress--;
	//log('Server said: '+stringReceivedFromServer);
};

//centerY, centerX, and radius can be scalars. Does bounds checking
var paintCircle = function(byteRect, centerY, centerX, radius, redByte, greenByte, blueByte){
	var minYI = Math.max(0, Math.min(Math.floor(centerY-radius), byteRect.height-1));
	var maxYI = Math.max(0, Math.min(Math.ceil(centerY+radius), byteRect.height-1));
	var minXI = Math.max(0, Math.min(Math.floor(centerX-radius), byteRect.width-1));
	var maxXI = Math.max(0, Math.min(Math.ceil(centerX+radius), byteRect.width-1));
	var radiusSq = radius*radius;
	for(var y=minYI; y<=maxYI; y++){
		var i = byteRect.index(y, minXI, 0);
		for(var x=minXI; x<=maxXI; x++){
			var dy = y-centerY;
			var dx = x-centerX;
			if(dy*dy + dx*dx <= radiusSq){
				byteRect.bytes[i+colorDimRed] = redByte;
				byteRect.bytes[i+colorDimGreen] = greenByte;
				byteRect.bytes[i+colorDimBlue] = blueByte;
			}
			i += 4;
		}
	}
};

var normColorVec = function(colorVec){
	var len = Math.sqrt(colorVec[0]*colorVec[0] + colorVec[1]*colorVec[1] + colorVec[2]*colorVec[2]);
	if(len == 0){
		colorVec[0] = colorVec[1] = colorVec[2] = Math.sqrt(1/3); //white, in this unit vector model
	}else{
		colorVec[0] /= len;
		colorVec[1] /= len;
		colorVec[2] /= len;
	}
};

var angle0InclTo2PiExcl = function(angle){
	var circle = 2*Math.PI;
	angle %= circle;
	if(angle < 0) angle += circle;
	return angle;
};

var angleNegPiToPiExcl = function(angle){
	angle = angle0InclTo2PiExcl(angle);
	if(Math.PI <= angle) angle -= 2*Math.PI
	return angle;
};

//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
	this.index = function(y, x, colorDim){
		return (y*this.width+x)*4+colorDim;
	};
	this.read = function(y, x, colorDim){
		return this.bytes[(y*this.width+x)*4+colorDim];
	};
	this.write = function(y, x, colorDim, bright){
		this.bytes[(y*this.width+x)*4+colorDim] = bright;
	};
	this.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
		var indexStart = this.index(y, fromX, colorDim);
		var pixelSiz = toXExclusive-fromX;
		var siz = pixelSiz*4;
		var bright = fromBright;
		var brightAdd = (toBright-fromBright)/pixelSiz;
		for(var i=0; i<siz; i+=4){
			bright += brightAdd;
			this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
		}
	};
};

var Point = function(index, py, px, radius){
	this.index = index;
	this.py = py; //position
	this.px = px;
	this.seeY = py; //where I want to go because see part of target object. Can only see near.
	this.seeX = px;
	//How much does this point think its found part of the on screen object?
	//Points that are less locked on should move more or follow those which are locked on more
	//and follow those not locked on less, or something like that.
	//When I'm holding the loop in my hands, it often misses a section of the loop and pulls it tight
	//between 2 places it is locked on, or is too loose.
	this.fractionLockedOn = .5;
	this.prevPoint = null;
	this.nextPoint = null;
	this.radius = radius;
	this.wantColor = [1, .3, .3];
	this.seeColor = [1,1,1];
	normColorVec(this.wantColor);
	normColorVec(this.seeColor);
	
	//this.forcesDistMult = 5;
	this.forcesDistMult = .1;
	
	this.forcesSmMult = .05;
	//this.forcesSmMult = .2;
	
	this.amountSee = .000001;
	this.minAmountSeeToMove = 1000000; //set by caller of this.see based on all Points' this.amountSee
	
	this.moveDigitalMult = 200;
	
	this.resetForces = function(){
		this.forcesY = 0; //Sum various forces into here then norm them and move a constant distance in this direction
		this.forcesX = 0;
		this.forcesDistY = 0; //Sum nonlinear distance constraint forces into here, then to forcesY and X
		this.forcesDistX = 0;
		//this.forcesMidY = 0; //Force from moving toward middle of prevPoint and nextPoint
		//this.forcesMidX = 0;
		//this.forcesSeeY = 0;
		//this.forcesSeeX = 0;
	};
	
	//writes forcesY and forcesX as a unit vector, after reading the dist, mid, and see forces andOr positions
	this.normThenMergeForcesThenNormAgain = function(){
		var fY = 0;
		var fX = 0;
		
		var forcesDistLen = Math.sqrt(this.forcesDistY*this.forcesDistY + this.forcesDistX*this.forcesDistX);
		if(forcesDistLen != 0){
			var mult = this.forcesDistMult/forcesDistLen;
			fY += this.forcesDistY*mult;
			fX += this.forcesDistX*mult;
		}
		
		//sm is see and mid (TODO in what proportion?).
		//Average their positions since mid should be small, and see varies more.
		//var smPy = (this.seeY + this.midY)/2;
		//var smPx = (this.seeX + this.midX)/2;
		var smPy = this.seeY;
		var smPx = this.seeX;
		var smDy = smPy-this.py;
		var smDx = smPx-this.px;
		var smLen = Math.sqrt(smDy*smDy + smDx*smDx);
		if(smLen != 0){
			var mult = this.forcesSmMult/smLen;
			fY += smDy*mult;
			fX += smDx*mult;
		}
		
		var fLen = Math.sqrt(fY*fY + fX*fX);
		if(fLen != 0){
			fY /= fLen;
			fX /= fLen;
		}
		
		this.forcesY = fY;
		this.forcesX = fX;
	};
	
	this.see = function(byteRect){ //update seeY and seeX if certain enough of what it sees
		var pyI = Math.max(0, Math.min(Math.round(this.py), byteRect.height-1));
		var pxI = Math.max(0, Math.min(Math.round(this.px), byteRect.width-1));
		var radiusI = Math.round(this.radius);
		var sumY = 0;
		var sumMassY = 0;
		var fromY = Math.max(0, Math.min(pyI-radiusI, byteRect.height-1));
		var toYExcl = Math.max(0, Math.min(pyI+radiusI+1, byteRect.height));
		normColorVec(this.wantColor);
		var seeCol = [1,1,1];
		var sqrt3 = Math.sqrt(3);
		for(var colorDim=0; colorDim<3; colorDim++){
			this.seeColor[colorDim] = 0;
		}
		//TODO merge duplicate code
		for(var yI=fromY; yI<toYExcl; yI++){
			for(var colorDim=0; colorDim<3; colorDim++){
				seeCol[colorDim] = byteRect.read(yI, pxI, colorDim)/255;
				this.seeColor[colorDim] += seeCol[colorDim];
			}
			//error: need brightness, but this makes everything equally bright: normColorVec(seeCol);
			var fractionMatch = (seeCol[0]*this.wantColor[0] + seeCol[1]*this.wantColor[1] + seeCol[2]*this.wantColor[2])/sqrt3;
			//var fractionMatch = seeCol[0]; //FIXME use dotProd like above
			fractionMatch *= .999999; //in case round slightly above 1
			if(fractionMatch < 0 || 1 < fractionMatch) throw 'fractionMatch='+fractionMatch;
			//var fractionMatch = byteRect.read(yI, pxI, colorDimRed, 255)/255; //TODO "target color" using all 3 colorDims
			sumMassY += fractionMatch;
			sumY += yI*fractionMatch;
		}
		var sumX = 0;
		var sumMassX = 0;
		var fromX = Math.max(0, Math.min(pxI-radiusI, byteRect.width-1));
		var toXExcl = Math.max(0, Math.min(pxI+radiusI+1, byteRect.width));
		for(var xI=fromX; xI<toXExcl; xI++){
			for(var colorDim=0; colorDim<3; colorDim++){
				seeCol[colorDim] = byteRect.read(pyI, xI, colorDim)/255;
				this.seeColor[colorDim] += seeCol[colorDim];
			}
			//error: need brightness, but this makes everything equally bright: normColorVec(seeCol);
			var fractionMatch = (seeCol[0]*this.wantColor[0] + seeCol[1]*this.wantColor[1] + seeCol[2]*this.wantColor[2])/sqrt3;
			//var fractionMatch = seeCol[0]; //FIXME use dotProd like above
			//if(this.index == 4) log('fractionMatch: '+fractionMatch);
			fractionMatch *= .999999; //in case round slightly above 1
			if(fractionMatch < 0 || 1 < fractionMatch) throw 'fractionMatch='+fractionMatch;
			//var fractionMatch = byteRect.read(pyI, xI, colorDimRed, 255)/255; //TODO "target color" using all 3 colorDims
			sumMassX += fractionMatch;
			sumX += xI*fractionMatch;
		}
		this.amountSee = (sumMassY + sumMassX)/2;
		
		//var minSee = 1.5;
		//var minSee = .5;
		//var minSee = .2;
		//var minSee = .1;
		
		//this.minAmountSeeToMove should be set after prev call to this.see based on average amountSee of all Points
		//if(this.index == 7) log('point7 this.minAmountSeeToMove='+this.minAmountSeeToMove+' this.amountSee='+this.amountSee+' y='+this.py+' x='+this.px+' sumMassY='+sumMassY+' sumMassX='+sumMassX+' this.minAmountSeeToMove='+this.minAmountSeeToMove);
		if((this.minAmountSeeToMove <= sumMassY) && (this.minAmountSeeToMove <= sumMassX)){
			this.fractionLockedOn = 1;
			this.seeY = sumY/sumMassY;
			this.seeX = sumX/sumMassX;
			//if(this.index == 7) log('point7 seeY='+this.seeY+' seeX='+this.seeX);
		}else{
			this.fractionLockedOn = 0;
		}
		
		normColorVec(this.seeColor); //for decaySeeColorIntoWantColor
	};
	
	this.distance = function(otherPoint){
		var dy = otherPoint.py - this.py;
		var dx = otherPoint.px - this.px;
		return Math.sqrt(dy*dy + dx*dx);
	};
	
	this.distanceYX = function(y, x){
		var dy = y - this.py;
		var dx = x - this.px;
		return Math.sqrt(dy*dy + dx*dx);
	};
	
	this.moveToSee = function(){
		this.py = this.seeY;
		this.px = this.seeX;
	};
	
	this.moveDigital = function(seconds){
		var mult = seconds*this.moveDigitalMult;
		this.py += this.forcesY*mult;
		this.px += this.forcesX*mult;
	};
	
	this.paint = function(byteRect){
		var pyI = Math.max(0, Math.min(Math.round(this.py), byteRect.height-1));
		var pxI = Math.max(0, Math.min(Math.round(this.px), byteRect.width-1));
		var seeYI = Math.max(0, Math.min(Math.round(this.seeY), byteRect.height-1));
		var seeXI = Math.max(0, Math.min(Math.round(this.seeX), byteRect.width-1));
		//var tangentTargetYI = Math.max(0, Math.min(Math.round(this.tangentTargetY), byteRect.height-1));
		//var tangentTargetXI = Math.max(0, Math.min(Math.round(this.tangentTargetX), byteRect.width-1));
		var midYI = Math.max(0, Math.min(Math.round(this.midY), byteRect.height-1));
		var midXI = Math.max(0, Math.min(Math.round(this.midX), byteRect.width-1));
		var radiusI = Math.round(this.radius);
		var fromY = Math.max(0, Math.min(pyI-radiusI, byteRect.height-1));
		var toYExcl = Math.max(0, Math.min(pyI+radiusI, byteRect.height));
		//TODO rename this. Since its multiplied by bright which is a view of fractionLockedOn,
		//its not actually the color we want. Its the same direction of color but not magnitude.
		var wantColorByte = [];
		var bright = .5+.5*this.fractionLockedOn;
		for(var colorDim=0; colorDim<3; colorDim++){
			wantColorByte[colorDim] = Math.max(0, Math.min(Math.floor(this.wantColor[colorDim]*bright*256), 255));
		}
		for(var yI=fromY; yI<toYExcl; yI++){
			//byteRect.writeHoriz(yI, pxI-radiusI, pxI+radiusI, colorDimGreen, 255, 0);
			//byteRect.write(yI, pxI, colorDimGreen, 255);
			byteRect.write(yI, seeXI, colorDimBlue, 255);
			//byteRect.write(yI, tangentTargetXI, colorDimBlue, 255);
			//byteRect.write(yI, this.midXI, colorDimBlue, 255);
			var i = byteRect.index(yI, pxI, 0);
			for(var colorDim=0; colorDim<3; colorDim++){ //display this.wantColor as horizontal and vertical line
				byteRect.bytes[i+colorDim] = wantColorByte[colorDim];
			}
		}
		var fromX = Math.max(0, Math.min(pxI-radiusI, byteRect.width-1));
		var toXExcl = Math.max(0, Math.min(pxI+radiusI, byteRect.width));
		for(var xI=fromX; xI<toXExcl; xI++){
			//byteRect.write(pyI, xI, colorDimGreen, 255);
			byteRect.write(seeYI, xI, colorDimBlue, 255);
			//byteRect.write(tangentTargetYI, xI, colorDimBlue, 255);
			//byteRect.write(midYI, xI, colorDimBlue, 255);
			var i = byteRect.index(pyI, xI, 0);
			for(var colorDim=0; colorDim<3; colorDim++){ //display this.wantColor as horizontal and vertical line
				byteRect.bytes[i+colorDim] = wantColorByte[colorDim];
			}
		}
	};
	
	this.toString = function(){
		return "(Point index:"+this.index+" x"+this.px+" y"+this.py+")";
	};
	
	this.resetForces();
};

var SmartblobSeer = function(howManyCorners, centerY, centerX, radius){
	this.corners = [];
	this.firstRadius = radius;
	//TODO update based on ave radius of points, but be careful not to change that radius by changing this
	this.targetAdjacentDistance = -1;
	this.firstTimeDidPhysicsDigital = null;
	this.intervalPhysicsDigital = .01; //TODO vision less often? Or is reading a few small parts of it fast enough?
	//this.intervalPhysicsDigital = .001;
	//this.intervalPhysicsDigital = .5;
	this.callsOfPhysicsDigital = 0;
	//var pointRadius = 15;
	var pointRadius = 12;
	for(var i=0; i<howManyCorners; i++){
		var angle = 2*Math.PI*i/howManyCorners;
		var randY = (Math.random()*2-1)*1.5;
		var randX = (Math.random()*2-1)*1.5;
		var py = centerY-radius*Math.sin(angle) + randY;
		var px = centerX+radius*Math.cos(angle) + randX;
		this.corners.push(new Point(i, py, px, pointRadius));
	}
	for(var i=0; i<howManyCorners; i++){
		var a = this.corners[i];
		var b = this.corners[(i+1)%howManyCorners];
		var c = this.corners[(i+2)%howManyCorners];
		b.prevPoint = a;
		b.nextPoint = c;
	}
	this.updateTargetAdjacentDistance = function(){
		//var minRadius = this.firstRadius/2;
		//var maxRadius = this.firstRadius*2;
		var aveRadius = this.aveDevRadius()[0];
		var aveCircumference = aveRadius*2*Math.PI;
		var aveAdjDistIfCircle = aveCircumference/this.corners.length;
		//FIXME TODO this.targetAdjacentDistance = aveAdjDistIfCircle*1.5;
		this.targetAdjacentDistance = aveAdjDistIfCircle;
		return this.targetAdjacentDistance;
	};
	this.centerYX = function(){
		var sumY = 0;
		var sumX = 0;
		for(i in this.corners){
			var c = this.corners[i];
			sumY += c.py;
			sumX += c.px;
		};
		var centerY = sumY/this.corners.length;
		var centerX = sumX/this.corners.length;
		return [centerY, centerX];
	};
	//Returns 0 (inclusive) to 2*Math.PI (exclusive)
	//The more it bends, the less accurate this is, but need an estimated angle
	//to align points between js and java.
	//spreadByLinearInterpolate should use this to wrap spread differently.
	this.estimateAngleAsIfWasCircular = function(){
		var center = this.centerYX();
		var centerY = center[0];
		var centerX = center[0];
		var sumRotatedDy=0, sumRotatedDx=0;
		var retAngle = 0;
		var siz = this.corners.length;
		for(var i=0; i<siz; i++){
			//Measure perimeter from constant angles spread evenly around circle
			//so all rotatedDy will be about equal, and same for all rotatedDx.
			var fromAngle = 2*Math.PI*i/siz;
			var c = this.corners[i];
			var dy = c.py-centerY;
			var dx = c.px-centerX;
			var fromY0 = Math.sin(fromAngle);
			var fromX0 = Math.cos(fromAngle);
			//perpendicular
			var fromY1 = fromX0;
			var fromX1 = -fromY0;
			//affineTransform
			var rotatedDy = dy*fromX1 + dx*fromX0;
			var rotatedDx = dy*fromY1 + dx*fromY0;
			sumRotatedDy += rotatedDy;
			sumRotatedDx += rotatedDx;
		}
		if(sumRotatedDy != 0 || sumRotatedDx != 0){
			var len = Math.sqrt(sumRotatedDy*sumRotatedDy + sumRotatedDx*sumRotatedDx);
			var normY = sumRotatedDy/len;
			var normX = sumRotatedDx/len;
			var c = Math.acos(normX);
			retAngle = normY<0 ? 2*Math.PI-c : c;
			//retAngle = 2*Math.PI-retAngle + Math.PI/2; //start pointing right
		}
		return retAngle-Math.PI/2;
	};
	//Depends on 
	//Returns [ave, dev] of radius
	this.aveDevRadius = function(){
		//TODO merge duplicate code
		var center = this.centerYX();
		var centerY = center[0];
		var centerX = center[1];
		var rs = [];
		var sumRadius = 0;
		for(i in this.corners){
			var c = this.corners[i];
			var dy = c.py-centerY;
			var dx = c.px-centerX;
			var r = Math.sqrt(dy*dy + dx*dx);
			rs.push(r);
			sumRadius += r;
		};
		var ave = sumRadius/this.corners.length;
		var sumOfSquares = 0;
		for(i in rs){
			var diff = rs[i]-ave;
			sumOfSquares += diff*diff;
		}
		var aveSquare = sumOfSquares/this.corners.length;
		var dev = Math.sqrt(aveSquare);
		//log('aveDevRadius '+ave+' '+dev);
		return [ave, dev];
	};
	this.setAveDevRadius = function(aveDevNew){
		this.setAveDevRadiusUsingObserved(this.aveDevRadius(), aveDevNew);
	};
	this.multRadius = function(mult){
		var center = this.centerYX();
		var centerY = center[0];
		var centerX = center[1];
		for(i in this.corners){
			var c = this.corners[i];
			var dy = c.py-centerY;
			var dx = c.px-centerX;
			c.py = centerY + dy*mult;
			c.px = centerX + dx*mult;
		}
	};
	//If have what aveDevRadius returned, this is faster than computing it again
	this.setAveDevRadiusUsingObserved = function(aveDevOld, aveDevNew){
		var center = this.centerYX(); //TODO optimize only call this once? Is it much faster?
		var centerY = center[0];
		var centerX = center[1];
		var oldAve = aveDevOld[0];
		var oldDev = aveDevOld[1];
		if(oldDev == 0){
			log('oldDev is 0. End setAveDevRadiusUsingObserved early. time='+time());
		}
		var newAve = aveDevNew[0];
		var newDev = aveDevNew[1];
		for(i in this.corners){
			var c = this.corners[i];
			var dy = c.py-centerY;
			var dx = c.px-centerX;
			var r = Math.sqrt(dy*dy + dx*dx);
			if(r == 0) continue;
			var rNorm = (r-oldAve)/oldDev;
			var newR = Math.max(0, newAve + rNorm*newDev);
			var multR = newR/r;
			c.py = centerY+dy*multR;
			c.px = centerX+dx*multR;
		};
	};
	this.paint = function(byteRect){
		//for(var i=0; i<200; i++){
		//	byteRect.write(i, i, colorDimBlue, i);
		//}
		this.forEachCorner(function(c){ 
			c.paint(byteRect);
		});
		var firstCorner = this.corners[0];
		paintCircle(byteRect, firstCorner.py, firstCorner.px, firstCorner.radius/2, 128, 128, 128);
		var oppositeCorner = this.corners[Math.floor(this.corners.length/2)];
		paintCircle(byteRect, oppositeCorner.py, oppositeCorner.px, oppositeCorner.radius/2, 128, 128, 128);
		var topCorner = this.corners[Math.floor(this.corners.length/4)];
		paintCircle(byteRect, topCorner.py, topCorner.px, topCorner.radius/2, 210, 210, 210);
		var bottomCorner = this.corners[Math.floor(this.corners.length*3/4)];
		paintCircle(byteRect, bottomCorner.py, bottomCorner.px, bottomCorner.radius/2, 64, 64, 64);
	};
	this.forEachCorner = function(func){ //calls func(corner)
		//ERROR: Causes problems with "this" referring to the param func instead of this SmartblobSeer
		for(i in this.corners){
			func(this.corners[i]);
		};
	};
	//calls func(cornerHigh,cornerLow) where cornerHigh.index > cornerLow.index
	this.forEachSetOf2Corner = function(func){
		//ERROR: Causes problems with "this" referring to the param func instead of this SmartblobSeer
		for(var high=1; high<this.corners.length; high++){
			for(var low=0; low<high; low++){
				func(this.corners[high], this.corners[low]);
			}
		}
	};
	this.updateMinAmountsToSee = function(){
		/*var seeSum = 0;
		var count = 0;
		for(i=0; i<this.corners.length; i++){
			var a = this.corners[i].amountSee;
			if(0 < a){
				seeSum += a;
				count++;
			}
		}
		//if(this.corners.length/3 <= count){
		if(0 < seeSum){
			var aveSee = seeSum/count;
			for(i=0; i<this.corners.length; i++){
				this.corners[i].minAmountSeeToMove = aveSee/10; //TODO decay slowly toward it so different parts can see different amounts?
			}
		}*/
		for(i=0; i<this.corners.length; i++){
			this.corners[i].minAmountSeeToMove = .5; //FIXME use aveSee
		}
	};
	this.moveToSee = function(byteRect){
		this.forEachCorner(function(c){ 
			c.see(byteRect);
			c.moveToSee(byteRect);
		});
		this.updateMinAmountsToSee();
	};
	
	this.accelTowardSee = function(byteRect, seconds){
		this.forEachCorner(function(c){ 
			c.see(byteRect);
			//c.springAccelToward(c.seeY, c.seeX, 170*seconds);
			//c.springAccelToward(c.seeY, c.seeX, 1500*seconds);
			//c.accelTowardSee(seconds);
		});
		this.updateMinAmountsToSee();
	};
	this.frictionEtc = function(seconds){
		this.forEachCorner(function(c){ 
			c.decaySpeed(3.5*seconds);
			//c.decaySpeed(2.5*seconds);
			//c.decaySpeed(1.5*seconds);
			//c.decaySpeed(.5*seconds);
			//c.decaySpeed(.2*seconds);
			//c.limitSpeed(120);
			c.limitSpeed(60);
			//c.limitSpeed(30);
		});
	};
	this.tangentNorm = function(seconds){
		this.forEachCorner(function(c){
			c.refreshTangentTarget();
			//c.constAccelToward(c.tangentTargetY, c.tangentTargetX, seconds*.2);
			c.springAccelToward(c.tangentTargetY, c.tangentTargetX, seconds*100);
			//c.py = c.tangentTargetY; //FIXME accel instead
			//c.px = c.tangentTargetX;
			//var decay = Math.min(.3, seconds*15);
			//var decay = Math.min(.3, seconds*5);
			//c.decayPositionToward(c.tangentTargetY, c.tangentTargetX, decay);
		});
	};
	
	this.rotateCornerIndexs = function(i){
		if(i < 0) i += this.corners.length;
		var a = [];
		for(var j=0; j<this.corners.length; j++){
			a[j] = this.corners[(j+i)%this.corners.length];
		}
		this.corners = a;
	};

	//The decay var is how much to change positions
	//Whatever shape of loop, spreads its corners evenly around that shape
	//using linear interpolation of their y and x positions.
	//Similar to moving toward mid of the prev and next point, this slightly shrinks the shape.
	this.spreadByLinearInterpolateAndRotateAlongPerimeter = function(decay, angle){
		//this.setSpreadYXVarsByLinearInterpolate = function(){
		var siz = this.corners.length;
		
		/*angle -= Math.PI/2;
		angle = 2*Math.PI-angle;
		while(angle < 2*Math.PI) angle += 2*Math.PI;
		angle = angle%(2*Math.PI);
		*/
		
		var angleFraction = angle/(2*Math.PI);
		//var angleFraction = 0;
		//var angleFraction = .001;
		
		/*var mul = .005;
		if(angleFraction < .5) angleFraction *= mul;
		else angleFraction = 1-((1-angleFraction)*mul)
		*/
		
		
		//log('TODO Rotating '+angle);
		
		//angleFraction = 0;
		
		//If aligned on the same corner each time, it wont move but others will so they will
		//move away from it by random paths even though on average its correct.
		//To prevent that asymmetry, do it on random index each time by rotating the
		//corner array, doing the norm, then rotating it back.
		//Or could just change the math here to wrap differently.
		//That alone causes more shrinking than enlarging, and causes chaotic change of size,
		//and causes a little change in shape. To fix most of that,
		//keep radiuses on same bellcurve before and after this norm,
		//while letting external vision forces change the size and shape.
		var randIndex = Math.max(0, Math.min(Math.floor(Math.random()*siz), siz-1));
		this.rotateCornerIndexs(randIndex);
		
		var aveDevRadiusBeforeNorm = this.aveDevRadius();
		
		var oldY = [];
		var oldX = [];
		for(i in this.corners){
			var c = this.corners[i];
			oldY[i] = c.py;
			oldX[i] = c.px;
		}
		
		//Array from corners[0] to corners[corners.length], so first corner is first and last here
		var surfaceDist = [];
		var px = [];
		var py = [];
		surfaceDist[0] = 0;
		py[0] = this.corners[0].py;
		px[0] = this.corners[0].px;
		for(var i=0; i<siz; i++){
			var a = this.corners[i];
			var iNext = (i+1)%siz;
			var b = this.corners[iNext];
			surfaceDist[i+1] = surfaceDist[i] + a.distance(b);
		}
		var perimeter = surfaceDist[siz]; //distance around surface
		for(var i=0; i<siz; i++){
			var fraction = i/siz;
			fraction = (fraction+angleFraction)%1; //rotate along perimeter
			var correctDist = perimeter*fraction;
			//var correctDist = perimeter*(i+.5)/siz;
			for(var j=1; j<=siz; j++){ //TODO optimize using binary search
				if(correctDist < surfaceDist[j]){
					//put corners[i] between corners[j] and corners[j+1 wrapped]
					var distRemaining = correctDist-surfaceDist[j-1];
					var jNext = j%siz;
					var distNext = surfaceDist[jNext]-surfaceDist[j-1];
					var fraction = distRemaining/distNext; //How much of jNext to use vs j-1
					this.corners[i].py = this.corners[jNext].py*fraction + (1-fraction)*this.corners[j-1].py;
					this.corners[i].px = this.corners[jNext].px*fraction + (1-fraction)*this.corners[j-1].px;
					break;
				}
			}
		}
		
		//Restore 1-decay fraction of old positions, keeping decay fraction of new positions
		for(i in this.corners){
			var c = this.corners[i];
			c.py = oldY[i]*(1-decay) + decay*c.py;
			c.px = oldX[i]*(1-decay) + decay*c.px;
		}
		
		//keep new point spread but not change in bellcurve of radius
		//var newAveDev = [aveDevRadiusBeforeNorm[0], 0]; //FIXME use aveDevBeforeNorm or maybe amplify dev a little
		//this.setAveDevRadius(newAveDev);
		//this.setAveDevRadius(aveDevRadiusBeforeNorm);
		
		var aveDevRadiusAfterNorm = this.aveDevRadius();
		var mult = aveDevRadiusBeforeNorm[0]/aveDevRadiusAfterNorm[0];
		this.multRadius(mult); //restore original radius by scaling all from center by same mult. Keep same shape.
		
		//rotate corners back to original indexs
		this.rotateCornerIndexs(siz-randIndex);
	};
	
	//Obsoleted by physicsDigital?
	this.nonlinearAccel = function(seconds){
		for(var high=1; high<this.corners.length; high++){
			for(var low=0; low<high; low++){
				var a = this.corners[high];
				var b = this.corners[low];
				var accel = this.chooseNonlinearAccelBetween(a, b);
				if(accel != 0){
					a.constSymmetricAccelToward(b, accel*seconds);
				}
			}
		}
	};
	this.moveBySpeed = function(seconds){
		this.forEachCorner(function(c){
			c.moveBySpeed(seconds);
		});
	};
	this.stayInsideRectangle = function(yStart, xStart, yEndExcl, xEndExcl){
		for(i in this.corners){
			var c = this.corners[i];
			c.py = Math.max(yStart, Math.min(c.py, yEndExcl-1));
			c.px = Math.max(xStart, Math.min(c.px, xEndExcl-1));
		}
	};
	this.stayInsideCircle = function(centerY, centerX, maxRadius){
		if(maxRadius < 0) throw 'maxRadius='+maxRadius;
		for(i in this.corners){
			var c = this.corners[i];
			var dy = c.py-centerY;
			var dx = c.px-centerX;
			var r = Math.sqrt(dy*dy + dx*dx);
			if(maxRadius < r){
				var mult = maxRadius/r;
				c.py = centerY + dy*mult;
				c.px = centerX + dx*mult;
			}
		}
	};
	
	this.normPositions = function(){
		var y = [];
		var x = [];
		var siz = this.corners.length;
		for(var i=0; i<siz; i++){
			var c = this.corners[i];
			y[i] = c.py;
			x[i] = c.px;
		}
		var minDist = 7.5;
		for(var i=0; i<siz; i++){
			var c = this.corners[i];
			var lowIndex = (i+siz-1)%siz;
			var highIndex = (i+siz+1)%siz;
			var dy = y[highIndex]-y[lowIndex];
			var dx = x[highIndex]-x[lowIndex];
			var distSq = dy*dy + dx*dx;
			if(minDist*minDist <= distSq){
				c.py = (y[highIndex]+y[lowIndex])/2;
				c.px = (x[highIndex]+x[lowIndex])/2;
			}else{
				c.py = c.prevPy;
				c.px = c.prevPx;
			}
		}
	};
	
	this.indexDiff = function(indexA, indexB){
		var i = Math.abs(indexA-indexB);
		return Math.min(i, this.corners.length-i);
	};
	this.minDistanceArray = [];
	for(var i=0; i<Math.ceil(howManyCorners/2); i++){
		var angle = 2*Math.PI*i/howManyCorners;
		var	y0 = 0;
		var x0 = this.firstRadius;
		var y1 = this.firstRadius*Math.sin(angle);
		var x1 = this.firstRadius*Math.cos(angle);
		var dy = y1-y0;
		var dx = x1-x0;
		var d = Math.sqrt(dy*dy + dx*dx);
		this.minDistanceArray[i] = d*.2;
	}
	this.minDistance = function(cornerA, cornerB){
		var indexDiff = this.indexDiff(cornerA.index, cornerB.index);
		return this.minDistanceArray[indexDiff];
		/*
		var a = this.targetAdjacentDistance;
		if(indexDiff == 0){
			return 0;
		}else if(indexDiff == 1){
			return a;
		}else if(indexDiff == 2){
			return a*2;
		}else if(indexDiff == 3){
			return a*2.5;
		}else if(indexDiff == 4){
			return a*3.3;
		}else{
			return a*4.1;
		}*/
	};
	this.maxDistance = function(cornerA, cornerB){
		/*var indexDiff = this.indexDiff(cornerA.index, cornerB.index);
		//if(indexDiff < 5) return this.minDistance(cornerA, cornerB)*1.5;
		//if(indexDiff < 3) return this.minDistance(cornerA, cornerB)*1.2;
		return this.targetAdjacentDistance*indexDiff;
		*/
		return 1000000;
	};
	//this.nonlinearAccelMult = 128.5;
	this.nonlinearAccelMult = 70;
	//To prevent the curved loop from tangling or crossing itself or some of its parts
	//getting too close or far apart, define an accel between each pair
	//based on their distance on surface (by index), this.firstRadius, and their distance.
	this.chooseNonlinearAccelBetween = function(cornerA, cornerB){
		//var indexDiff = this.indexDiff(cornerA.index, cornerB.index);
		var distance = cornerA.distance(cornerB);
		var minD = this.minDistance(cornerA, cornerB);
		var maxD = this.maxDistance(cornerA, cornerB);
		if(minD<0 || maxD<0 || minD>maxD){
			throw 'minD='+minD+' maxD='+maxD;
		}
		if(distance < minD){
			return (distance-minD)*this.nonlinearAccelMult; //negative repels
		}else if(maxD < distance){
			return (distance-maxD)*this.nonlinearAccelMult; //positive attracts
		}else{
			return 0;
		}
	};
	
	this.physics = function(byteRect, seconds){
		//this.physicsDigitalWhileBehindSchedule(byteRect, seconds);
		var repeat = 20;
		//var repeat = 5;
		//var repeat = 10;
		//var repeat = 1;
		for(var r=0; r<repeat; r++){
			this.physicsDigitalOnce(byteRect, seconds/repeat);
		}
		//var ang = seer.estimateAngleAsIfWasCircular();
		//log('ang: '+ang);
		//this.spreadByLinearInterpolate(1);
	};
	
	/*this.physicsDigitalWhileBehindSchedule = function(byteRect, seconds){
		var now = time();
		var isTimeToDoPhysicsDigital = (this.callsOfPhysicsDigital==0)
			|| (this.firstTimeDidPhysicsDigital + this.intervalPhysicsDigital*this.callsOfPhysicsDigital <= now);
		if(isTimeToDoPhysicsDigital){
			this.physicsDigitalOnce(byteRect, seconds);
		}
	};*/
	
	//TODO optimize: create another function which does this same thing except doesnt update visual forces
	this.physicsDigitalOnce = function(byteRect, seconds){
		if(this.firstTimeDidPhysicsDigital == null) this.firstTimeDidPhysicsDigital = time();
		this.callsOfPhysicsDigital++;
		
		for(i in this.corners){
			this.corners[i].resetForces();
		}

		for(var high=1; high<this.corners.length; high++){
			for(var low=0; low<high; low++){
				var a = this.corners[high];
				var b = this.corners[low];
				var accel = this.chooseNonlinearAccelBetween(a, b);
				//Since this is physicSDigital, accel will get normed, so we dont need to multiply time
				if(accel != 0){
					var dy = b.py-a.py;
					var dx = b.px-a.px;
					var dist = Math.sqrt(dy*dy + dx*dx);
					if(dist != 0){
						var mult = .5*accel/dist;
						var forceYEach = dy*mult;
						var forceXEach = dx*mult;
						//FIXME is this backward?
						a.forcesDistY += forceYEach;
						a.forcesDistX += forceXEach;
						b.forcesDistY -= forceYEach;
						b.forcesDistX -= forceXEach;
					}
				}
			}
		}
		
		for(i in this.corners){
			this.corners[i].see(byteRect);
		}
		
		this.updateMinAmountsToSee();
		
		/*var decay = 1.5*seconds;
		for(i in this.corners){
			this.corners[i].decaySeeColorIntoWantColor(decay);
		}
		decay *= 4;
		for(i in this.corners){
			this.corners[i].blurColorToHere(decay);
		}*/
		
		//for(i in this.corners){
		//	this.corners[i].updateMid();
		//}
		
		
		for(i in this.corners){
			this.corners[i].normThenMergeForcesThenNormAgain();
		}
		
		var maxPointRadius = 0;
		for(i in this.corners){
			var c = this.corners[i];
			//c.moveDigital(this.intervalPhysicsDigital);
			c.moveDigital(seconds);
			maxPointRadius = Math.max(c.radius, maxPointRadius);
		}
		
		/*for(i in this.corners){
			this.corners[i].moveToSee();
		}*/
		
		
		var angle = angleNegPiToPiExcl(this.estimateAngleAsIfWasCircular());
		//var rotateMagnitude = .04;
		//var rotateMagnitude = .02; //because big rotation destabilizes it, and this is fast on screen
		var rotateMagnitude = .005;
		//var rotateMagnitude = 0;
		angle = angleNegPiToPiExcl(this.estimateAngleAsIfWasCircular())<0 ? rotateMagnitude : -rotateMagnitude;
		this.spreadByLinearInterpolateAndRotateAlongPerimeter(1, angle);
		
		
		//FIXME dont hardcode the visible area, but byteRect is 3 of these stacked vertically so I have to for now
		//this.stayInsideRectangle(256, 0, 384, 128);
		//var centerY = 128+128+64; //low 1/3
		var centerY = 64; //top 1/3
		var centerX = 64;
		var visibleRadius = 63;
		this.stayInsideCircle(centerY, centerX, visibleRadius-maxPointRadius);
	};
	
	/*this.physicsSmoothButUnstable = function(byteRect, seconds){
		this.seconds = Math.max(0, Math.min(seconds, .05));
		this.accelTowardSee(byteRect, seconds);
		this.tangentNorm(seconds);
		this.moveBySpeed(seconds);
		this.nonlinearAccel(seconds);
		this.moveBySpeed(seconds);
		this.frictionEtc(seconds);
		this.moveBySpeed(seconds);
		//FIXME dont hardcode the visible area, but byteRect is 3 of these stacked vertically so I have to for now
		this.stayInsideRectangle(256, 0, 384, 128);
	};*/
	
	//all positions range -1 to 1, around average position of points and normed by max radius
	this.relPositionsAsScalarArray = function(){
		//TODO merge duplicate code
		var sumY = 0;
		var sumX = 0;
		for(i in this.corners){
			var c = this.corners[i];
			sumY += c.py;
			sumX += c.px;
		};
		var centerY = sumY/this.corners.length;
		var centerX = sumX/this.corners.length;
		var maxRadius = 0;
		for(i in this.corners){
			var c = this.corners[i];
			var dy = c.py-centerY;
			var dx = c.px-centerX;
			var r = Math.sqrt(dy*dy + dx*dx);
			maxRadius = Math.max(r, maxRadius);
		};
		var a = [];
		for(i in this.corners){
			var c = this.corners[i];
			var dy = c.py-centerY;
			var dx = c.px-centerX;
			var dataY = dy/maxRadius;
			var dataX = dx/maxRadius;
			a.push(dataY);
			a.push(dataX);
		}
		return a;
	};
	this.relPositionsAsHexString = function(){
		var a = this.relPositionsAsScalarArray();
		var hex = '';
		for(i in a){
			hex += fourHexDigitsForBifraction(a[i]);
		}
		return hex;
	};
	//For now, just do this once when it starts, since could destabilize if change while running
	this.updateTargetAdjacentDistance();
	log('targetAdjacentDistance: '+this.targetAdjacentDistance);
};

var seer = new SmartblobSeer(32, 64, 64, 50);

var updateCanvasObjects = function(){
	canvasContext = canvas.getContext('2d');
	canvasImageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
	canvasPixels = canvasImageData.data;
	byteRect = new ByteRect(canvasPixels, canvas.height, canvas.width);
};

var pairFWA = function(left, right){
	return new FuncWhenAvl(null, left.minTime, left, right);
};

//Immutable avl tree of func each at a minTime.
//All functions return a new FuncWhenAvl or this if no change.
//left and right are both null or both FuncWhenAvl.
//Comparing min and max of scalars should lack roundoff.
//If roundoff, may find x < x and recurse wrong.
var FuncWhenAvl = function(funcIfLeaf, minTime, left, right){
	this.funcIfLeaf = funcIfLeaf; //null if not leaf
	this.minTime = minTime;
	this.left = left;
	this.right = right;
	if((left == null) != (right == null)) throw '1 child is null, but must be both or neither, in '+this;
	this.height = (left==null) ? 0 : Math.max(left.height, right.height)+1;
	this.maxHeightDiff = (this.height==0) ? 0 :
		Math.max(Math.abs(left.height-right.height), Math.max(left.maxHeightDiff, right.maxHeightDiff));
	this.size = this.height==0 ? 1 : 1+left.size+right.size;
	this.sizeLeafs = this.height==0 ? 1 : left.sizeLeafs+right.sizeLeafs;
		
	this.insert = function(func, minTime){
		return this.insertWithoutBalance(func, minTime).balance();
	};
	
	this.removeFirst = function(){
		var firstAndRoot = this.removeFirstWithoutBalance();
		return firstAndRoot[1]==null ? firstAndRoot : [firstAndRoot[0], firstAndRoot[1].balance()];
	};
	
	this.nextEventWhen = function(){
		return (this.height==0) ? this.minTime : this.left.nextEventWhen();
	};
	
	this.farthestFutureEventWhen = function(){
		return (this.height==0) ? this.minTime : this.right.farthestFutureEventWhen();
	};
	
	//Returns a new FuncWhenAvl containing the FuncWhen param at sorted position
	this.insertWithoutBalance = function(func, minTime){
		//log('START insertWithoutBalance on this='+this+' inserting minTime='+minTime);
		if(this.height == 0){
			var insertLeaf = new FuncWhenAvl(func, minTime, null, null);
			if(this.minTime < minTime){
				return pairFWA(this, insertLeaf);
			}else{
				return pairFWA(insertLeaf, this);
			}
		}else{
			if(this.right.minTime <= minTime){
				var newRight = this.right.insertWithoutBalance(func, minTime);
				//log('oldRight (inserting minTime '+minTime+') = '+this.right);
				//log('newRight (inserting minTime '+minTime+') = '+newRight);
				return pairFWA(this.left, newRight);
			}else{
				var newLeft = this.left.insertWithoutBalance(func, minTime);
				//log('oldLeft (inserting minTime '+minTime+') = '+this.left);
				//log('newLeft (inserting minTime '+minTime+') = '+newLeft);
				return pairFWA(newLeft, this.right);
			}
		}
	};
	
	//Returns [first, newRootExcludingThat]. If removeFirst of root, the new root is null.
	this.removeFirstWithoutBalance = function(){
		if(this.height==0){
			return [this, null];
		}else if(this.left.height==0){
			return [this.left, this.right];
		}else{
			var firstAndRoot = this.left.removeFirstWithoutBalance();
			return [firstAndRoot[0], pairFWA(firstAndRoot[1], this.right)];
		}
	};
	
	//Returns a new FuncWhenAvl if was unbalanced, else quickly returns this.
	//TODO balanceTree func could be avoided by creating it already balanced.
	//TODO These WHILE loops should probably be IF.
	this.balance = function(){
		if(this.maxHeightDiff <= 1) return this;
		var x = this;
		var first = x.left, second = x.right;
		var newFirst = first.maxHeightDiff <= 1
			? first
			: first.balance();
		var newSecond = second.maxHeightDiff <= 1
			? second
			: second.balance();
		while (newFirst.height + 1 < newSecond.height){
			// newLeft needs to be deeper or newRight shallower.
			// newRight is not a leaf so this always works.
			if (newSecond.left.height > newSecond.left.height){
				// Right-rotate newRight so newRight.firstOrNull.height <=
				// newRight.left.height.
				// newRight.firstOrNull is not a leaf.
				newSecond = pairFWA(
					newSecond.left.left,
					pairFWA(
						newSecond.left.right,
						newSecond.right
					)
				);
			}
			// Move newRight.firstOrNull to newLeft.
			newFirst = pairFWA(newFirst, newSecond.left).balance();
			newSecond = newSecond.right;
		}
		// only 1 of the while loops will execute
		while (newFirst.height > newSecond.height + 1){
			// newRight needs to be deeper or newLeft shallower.
			// newLeft is not a leaf so this always works.
			if (newFirst.left.height > newFirst.left.height){
				// testLeftRotate++;
				// Left-rotate newLeft so newLeft.left.height <=
				// newLeft.firstOrNull.height.
				// newLeft.left is not a leaf.
				newFirst = pairFWA(
					pairFWA(
						newFirst.left,
						newFirst.right.left
					),
					newFirst.right.right
				);
			}
			// Move newLeft.left to newRight.
			newSecond = pairFWA(newFirst.right,newSecond).balance();
			newFirst = newFirst.left;
		}
		return pairFWA(newFirst, newSecond);
	};
	
	this.toString = function(){
		if(this.height == 0) return '(t='+this.minTime+')';
		return '(s='+this.size+' sl='+this.sizeLeafs+' '+toStringCheckForUndefinedAndNull(this.left)+toStringCheckForUndefinedAndNull(this.right)+')';
	};
	
};

var rootFuncWhenAvl = null;

//Use this instead of multiple uses of setTimeout or setInterval because its far more thread safe but not exactly.
//More precise order than setTimeout with millisecond delay, but the main reason to use this is
//it (TODO verify) guarantees all will run instead of cutting some off if they take too long like setTimeout does.
//It also allows functions to check which other functions are scheduled and in what order,
//which would be useful if you want to cancel them, and organize things into many small parts.
//Schedules a func to run at minTime or later. It will be at minTime if other funcs finish in time.
//Time is a value of time().
//For repeated funcs, you should wait to schedule it again until the next scheduled call of it finishes.
var schedf = function(minTime, func){
	//log('start schedf minTime='+minTime);
	var r = rootFuncWhenAvl;
	if(r == null){
		rootFuncWhenAvl = new FuncWhenAvl(func, minTime, null, null);
	}else{
		rootFuncWhenAvl = r.insert(func, minTime);
	}
};

//Schedule func for after the current function in progress finishes
var schedfNext = function(func){
	var r = rootFuncWhenAvl;
	if(r == null){
		schedf(time(), func);
	}else{
		//2^-20 considering binary digits precision of float64 and dates up to around year 2100
		schedf(r.nextEventWhen()-Math.pow(2,-16), func);
	}
}

//Schedule func for just after the farthest future scheduled func
var schedfLast = function(func){
	var r = rootFuncWhenAvl;
	if(r == null){
		schedf(time(), func);
	}else{
		//2^-20 considering binary digits precision of float64 and dates up to around year 2100
		schedf( Math.max(r.farthestFutureEventWhen()+Math.pow(2,-16), time()) , func);
	}
};

var timerForScheduledFunctions = function(){
	var r = rootFuncWhenAvl; //in case rootFuncWhenAvl changes between multiple reads of it before writing it in loop body
	//if(r != null){ //FIXME do while
	while(r != null){
		//log('root '+r);
		var firstAndRoot = r.removeFirst(); //immutable so doesnt change rootFuncWhenAvl
		//var firstAndRoot = r.removeFirstWithoutBalance(); //immutable so doesnt change rootFuncWhenAvl
		var first = firstAndRoot[0];
		var now = time();
		if(first.minTime <= now){ //At or past its scheduled time, so remove it from scheduler then run it
			//log('BEFORE run next func, root = '+r);
			
			r = rootFuncWhenAvl = firstAndRoot[1]; //new balanced avl tree node excluding first
			//log('BEFORE run next func, root with first removed = '+r);
			
			//if(r != null){
			//	//log("AVL BALANCE TEST... ["+r+"]");
			//	r = rootFuncWhenAvl = r.balance();
			//	//log("BALANCED:           ["+r+"]");
			//}
			
			first.funcIfLeaf();
			
			//log('AFTER run that func');
		}else{
			r = null; //all scheduled in future, or none scheduled
		}
	}
	//TODO what small interval should it check if there are more funcs scheduled?
	//TODO smaller delay after its working
	//setTimeout(timerForScheduledFunctions, 300); //few milliseconds should be ok since on most loops it does nothing
	r = rootFuncWhenAvl;
	var millisWait = 32;
	if(r != null){
		var t = r.nextEventWhen();
		var until = t-time();
		millisWait = Math.max(1, Math.ceil(until*1000));
	}
	setTimeout(timerForScheduledFunctions, millisWait); //few milliseconds should be ok since on most loops it does nothing
};

/*
schedf(time()+3, function(){ log('at 3'); });
schedf(time()+5, function(){ log('at 5'); });
schedf(time()+8, function(){ log('at 8'); });
schedf(time()+2, function(){ log('at 2'); });
schedf(time()+1, function(){ log('at 1'); });
schedf(time()+4, function(){ log('at 4'); });
schedf(time()+4, function(){ log('at 4 again'); });
schedf(time()+4, function(){ log('at 4 again2'); });
schedf(time()+4, function(){ log('at 4 again3'); });
schedf(time()+4, function(){ log('at 4 again4'); });
schedf(time()+4, function(){ log('at 4 again5'); });
schedf(time()+6, function(){ log('at 6'); });
schedf(time()+7, function(){ log('at 7'); });
*/

var noStream = function(){
	log('noStream from webcam');
};

var timePrevCycle = time(); //mainLoop

var mainLoop = function(){
	schedf(time()+.05, mainLoop);

	canvasContext.drawImage(video, 0, 0, canvas.width, canvas.height);
	updateCanvasObjects();
	//canvasContext.putImageData(canvasImageData, 0, 0);
	
	var now = time();
	var seconds = now-timePrevCycle;
	timePrevCycle = now;
	var secondsTruncated = Math.max(0, Math.min(seconds, .03));
	seer.physics(byteRect, secondsTruncated);
	
	startOneAjax();
	
	seer.paint(byteRect);
	canvasContext.putImageData(canvasImageData, 0, 0);
	
	
	//schedfLast(mainLoop);
	//schedf(time()+.01, mainLoop);
	//schedf(time()+.025, mainLoop);
	//schedf(time()+.03, mainLoop);
	//schedf(time()+.05, mainLoop);
};

var startOneAjax = function(){
	ajaxSend("player0Smartblob/"+seer.relPositionsAsHexString());
};

var mainAjaxLoop = function(){
	schedf(time()+.5, mainAjaxLoop); //TODO faster
	startOneAjax();
	//schedfLast(mainAjaxLoop);
};

var gotStream = function(stream){
	videoStream = stream;
	log('Got stream.');
	video.onerror = function ()
	{
		log('video.onerror');
		if (video) stop();
	};
	stream.onended = noStream;
	if (window.webkitURL) video.src = window.webkitURL.createObjectURL(stream);
	else if (video.mozSrcObject !== undefined)
	{//FF18a
		video.mozSrcObject = stream;
		video.play();
	}
	else if (navigator.mozGetUserMedia)
	{//FF16a, 17a
		video.src = stream;
		video.play();
	}
	else if (window.URL) video.src = window.URL.createObjectURL(stream);
	else video.src = stream;
	
	var now = time();
	//schedf(now+.01, updateCanvasObjects);
	//schedf(now+.02, mainLoop);
	updateCanvasObjects();
	schedfLast(mainLoop);
	
	//schedfLast(mainAjaxLoop);
	//schedf(time()+5,mainAjaxLoop);
	
	//video.addEventListener("timeupdate", mainLoop, false);
	
	
		
	//var testDiv = document.getElementById('testDiv');
	//for(i in videoStream){
	//	testDiv.innerHTML += '<br>videoStream['+i+'] = '+videoStream[i];
	//}
};

schedfNext(function(){
	if ((typeof window === 'undefined') || (typeof navigator === 'undefined')) log('This page needs a Web browser with the objects window.* and navigator.*!');
	else if (!(video && canvas)) log('HTML context error!');
	else
	{
		log('Get user media…');
		if (navigator.getUserMedia) navigator.getUserMedia({video:true}, gotStream, noStream);
		else if (navigator.oGetUserMedia) navigator.oGetUserMedia({video:true}, gotStream, noStream);
		else if (navigator.mozGetUserMedia) navigator.mozGetUserMedia({video:true}, gotStream, noStream);
		else if (navigator.webkitGetUserMedia) navigator.webkitGetUserMedia({video:true}, gotStream, noStream);
		else if (navigator.msGetUserMedia) navigator.msGetUserMedia({video:true, audio:false}, gotStream, noStream);
		else log('getUserMedia() not available from your Web browser!');
	}
});

//schedfNext(mainAjaxLoop); //first ajax call must precede webcam andOr canvas events else they dont work for strange reason

//log("AVL BALANCE TEST...");
//log("BALANCED: "+rootFuncWhenAvl.balance());

window.onload = timerForScheduledFunctions;

</script>
</body></html>